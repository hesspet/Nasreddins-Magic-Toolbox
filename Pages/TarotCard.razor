@page "/tarot"
@using System.Linq
@using System.IO

<PageTitle>@DisplayTexts.TarotPageTitle</PageTitle>

<h1>@DisplayTexts.TarotHeader</h1>

<p>@(new MarkupString(DisplayTexts.TarotSearchInstructions))</p>

<div class="tarot-search">
    <label class="form-label" for="cardNameInput">@DisplayTexts.TarotSearchLabel</label>
    <input id="cardNameInput"
           class="form-control"
           @bind="SearchTerm"
           @bind:event="oninput"
           placeholder="@DisplayTexts.TarotSearchPlaceholder" />
</div>

@if (HasSearched && selectedCard is null)
{
    <p class="text-danger">@DisplayTexts.TarotSearchNotFound</p>
}

@if (selectedCard is not null)
{
    <figure class="tarot-card">
        <img src="@selectedCard.ImagePath" alt="@selectedCard.DisplayName" class="img-fluid" />
        <figcaption>@selectedCard.DisplayName</figcaption>
    </figure>
}

@code {
    private string searchTerm = string.Empty;
    private TarotCardInfo? selectedCard;
    private bool HasSearched => !string.IsNullOrWhiteSpace(searchTerm);

    private string SearchTerm
    {
        get => searchTerm;
        set
        {
            if (searchTerm == value)
            {
                return;
            }

            searchTerm = value ?? string.Empty;
            UpdateSelection();
        }
    }

    private static readonly IReadOnlyList<TarotCardInfo> Cards = LoadCards();

    private static IReadOnlyList<TarotCardInfo> LoadCards()
    {
        var imagesRoot = Path.Combine(AppContext.BaseDirectory, "wwwroot", "images");
        if (!Directory.Exists(imagesRoot))
        {
            return Array.Empty<TarotCardInfo>();
        }

        return Directory.EnumerateDirectories(imagesRoot, "*", SearchOption.TopDirectoryOnly)
                        .SelectMany(deckDirectory => LoadDeck(deckDirectory))
                        .OrderBy(card => card.DisplayName)
                        .ToList();
    }

    private static IEnumerable<TarotCardInfo> LoadDeck(string deckDirectory)
    {
        var deckName = Path.GetFileName(deckDirectory);
        return Directory.EnumerateFiles(deckDirectory, "*.jpg", SearchOption.TopDirectoryOnly)
                        .Select(filePath =>
                        {
                            var fileName = Path.GetFileName(filePath);
                            var displayName = CreateDisplayName(deckName, fileName);
                            var key = CreateKey(deckName, fileName);
                            return new TarotCardInfo(displayName, deckName, fileName, key);
                        });
    }

    private static string CreateDisplayName(string deckName, string fileName)
    {
        var nameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
        var cardName = nameWithoutExtension.Replace('_', ' ');
        var friendlyDeckName = deckName.Replace('_', ' ');
        return $"{friendlyDeckName}: {cardName}";
    }

    private static string CreateKey(string deckName, string fileName)
    {
        var composite = string.Concat(deckName, "_", Path.GetFileNameWithoutExtension(fileName));
        var filtered = composite.Where(char.IsLetterOrDigit);
        return string.Concat(filtered);
    }

    private void UpdateSelection()
    {
        selectedCard = null;

        var normalized = NormalizeForComparison(searchTerm);
        if (normalized.Length == 0)
        {
            return;
        }

        selectedCard = Cards.FirstOrDefault(card => card.ComparisonKey.Contains(normalized, StringComparison.OrdinalIgnoreCase));
    }

    private static string NormalizeForComparison(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return string.Empty;
        }

        var filtered = value.Where(char.IsLetterOrDigit)
                            .Select(char.ToLowerInvariant);
        return string.Concat(filtered);
    }

    private sealed record TarotCardInfo(string DisplayName, string DeckName, string FileName, string Key)
    {
        public string ImagePath => $"images/{DeckName}/{FileName}";
        public string ComparisonKey => NormalizeForComparison(Key);
    }
}
