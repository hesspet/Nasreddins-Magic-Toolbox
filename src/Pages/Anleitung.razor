@page "/anleitung"
@using System.Collections.Generic
@using System.Globalization
@using System.Linq
@using System.Reflection
@using System.Text
@using System.Text.RegularExpressions
@using Markdig
@using Markdig.Syntax
@using Markdig.Syntax.Inlines
@implements IAsyncDisposable
@inject IJSRuntime JsRuntime

<PageTitle>@DisplayTexts.InstructionsPageTitle</PageTitle>

<h1>@DisplayTexts.InstructionsPageHeader</h1>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger instructions-error" role="alert">@errorMessage</div>
}
else
{
    <div class="instructions-page">
        <nav class="instructions-toc" aria-label="@DisplayTexts.InstructionsTableOfContentsLabel">
            <h2 class="visually-hidden">@DisplayTexts.InstructionsTableOfContentsLabel</h2>
            <ul class="instructions-toc-list">
                @foreach (var heading in headings)
                {
                    <li>
                        <button type="button"
                                class="instructions-toc-button"
                                @onclick="() => ScrollToHeadingAsync(heading.Id)">
                            @heading.Text
                        </button>
                    </li>
                }
            </ul>
        </nav>

        <section class="instructions-content" @ref="contentContainer">
            @if (!string.IsNullOrEmpty(instructionsHtml))
            {
                <article class="instructions-markdown">@((MarkupString)instructionsHtml)</article>
            }
        </section>
    </div>
}

@code {
    private sealed record InstructionHeading(string Id, string Text);

    private static readonly MarkdownPipeline Pipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .Build();

    private readonly HashSet<string> headingIds = new(StringComparer.OrdinalIgnoreCase);
    private ElementReference contentContainer;
    private IJSObjectReference? module;
    private List<InstructionHeading> headings = new();
    private string? instructionsHtml;
    private string? errorMessage;
    private int headingFallbackCounter = 1;

    protected override void OnInitialized()
    {
        try
        {
            LoadInstructions();
        }
        catch
        {
            errorMessage = DisplayTexts.InstructionsContentError;
        }
    }

    private void LoadInstructions()
    {
        var assembly = typeof(Program).Assembly;
        var resourceName = assembly
            .GetManifestResourceNames()
            .FirstOrDefault(name => name.EndsWith(".Help.anleitung.md", StringComparison.OrdinalIgnoreCase));

        if (resourceName is null)
        {
            errorMessage = DisplayTexts.InstructionsContentError;
            return;
        }

        using var stream = assembly.GetManifestResourceStream(resourceName);

        if (stream is null)
        {
            errorMessage = DisplayTexts.InstructionsContentError;
            return;
        }

        using var reader = new StreamReader(stream, Encoding.UTF8, leaveOpen: false);
        var markdown = reader.ReadToEnd();

        if (string.IsNullOrWhiteSpace(markdown))
        {
            errorMessage = DisplayTexts.InstructionsContentError;
            return;
        }

        var document = Markdown.Parse(markdown, Pipeline);
        headingIds.Clear();
        headingFallbackCounter = 1;

        headings = document
            .Descendants<HeadingBlock>()
            .Where(block => block.Level == 1)
            .Select(CreateHeading)
            .Where(item => item is not null)
            .Select(item => item!)
            .ToList();

        instructionsHtml = ApplyHeadingIds(
            Markdown.ToHtml(document, Pipeline),
            headings);
    }

    private InstructionHeading? CreateHeading(HeadingBlock heading)
    {
        var text = GetHeadingText(heading);

        if (string.IsNullOrEmpty(text))
        {
            return null;
        }

        var headingId = GenerateHeadingId(text);
        return new InstructionHeading(headingId, text);
    }

    private static string GetHeadingText(HeadingBlock heading)
    {
        if (heading.Inline is null)
        {
            return string.Empty;
        }

        var builder = new StringBuilder();
        AppendInlineText(heading.Inline, builder);
        return builder.ToString().Trim();
    }

    private static readonly Func<HtmlEntityInline, string?> HtmlEntityAccessor = CreateHtmlEntityAccessor();

    private static void AppendInlineText(Inline inline, StringBuilder builder)
    {
        switch (inline)
        {
            case LiteralInline literal:
                builder.Append(literal.Content.ToString());
                break;
            case CodeInline code:
                builder.Append(code.Content);
                break;
            case HtmlInline html:
                builder.Append(html.Tag);
                break;
            case LineBreakInline:
                builder.Append(' ');
                break;
            case ContainerInline containerInline:
                foreach (var child in containerInline)
                {
                    AppendInlineText(child, builder);
                }
                break;
            default:
                switch (inline)
                {
                    case AutolinkInline autolink:
                        builder.Append(autolink.Url.ToString());
                        break;
                    case HtmlEntityInline entity:
                        builder.Append(entity.Transcoded ?? HtmlEntityAccessor(entity) ?? string.Empty);
                        break;
                    default:
                        builder.Append(inline.ToString());
                        break;
                }
                break;
        }
    }

    private static Func<HtmlEntityInline, string?> CreateHtmlEntityAccessor()
    {
        var property = typeof(HtmlEntityInline).GetProperty(
            "HtmlEntity",
            BindingFlags.Public | BindingFlags.Instance);

        if (property is not null && property.PropertyType == typeof(string))
        {
            return entity => property.GetValue(entity) as string;
        }

        return _ => null;
    }

    private string GenerateHeadingId(string text)
    {
        var normalized = RemoveDiacritics(text.Trim().ToLowerInvariant());
        normalized = Regex.Replace(normalized, "[^a-z0-9]+", "-").Trim('-');

        if (string.IsNullOrEmpty(normalized))
        {
            normalized = $"abschnitt-{headingFallbackCounter++}";
        }

        return EnsureUniqueId(normalized);
    }

    private string EnsureUniqueId(string id)
    {
        var normalized = Regex.Replace(id.Trim(), "[^A-Za-z0-9-]+", "-").Trim('-');

        if (string.IsNullOrEmpty(normalized))
        {
            normalized = $"abschnitt-{headingFallbackCounter++}";
        }

        var uniqueId = normalized;
        var suffix = 2;

        while (!headingIds.Add(uniqueId))
        {
            uniqueId = $"{normalized}-{suffix++}";
        }

        return uniqueId;
    }

    private static string ApplyHeadingIds(string html, IReadOnlyList<InstructionHeading> headingList)
    {
        if (string.IsNullOrEmpty(html) || headingList.Count == 0)
        {
            return html;
        }

        var index = 0;
        return Regex.Replace(
            html,
            "<h1(?<attrs>[^>]*)>",
            match =>
            {
                if (index >= headingList.Count)
                {
                    return match.Value;
                }

                var heading = headingList[index++];
                var attributes = match.Groups["attrs"].Value;
                var idPattern = "\\sid\\s*=\\s*\"[^\"]*\"";

                if (Regex.IsMatch(attributes, idPattern, RegexOptions.IgnoreCase))
                {
                    attributes = Regex.Replace(
                        attributes,
                        idPattern,
                        $" id=\"{heading.Id}\"",
                        RegexOptions.IgnoreCase);
                }
                else
                {
                    attributes = $"{attributes} id=\"{heading.Id}\"";
                }

                return $"<h1{attributes}>";
            },
            RegexOptions.IgnoreCase);
    }

    private static string RemoveDiacritics(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return string.Empty;
        }

        var normalized = text.Normalize(NormalizationForm.FormD);
        var builder = new StringBuilder(normalized.Length);

        foreach (var character in normalized)
        {
            var category = CharUnicodeInfo.GetUnicodeCategory(character);

            if (category != UnicodeCategory.NonSpacingMark)
            {
                builder.Append(character);
            }
        }

        return builder.ToString().Normalize(NormalizationForm.FormC);
    }

    private async Task ScrollToHeadingAsync(string headingId)
    {
        if (string.IsNullOrWhiteSpace(headingId))
        {
            return;
        }

        var jsModule = await GetModuleAsync();
        await jsModule.InvokeVoidAsync("scrollToHeading", contentContainer, headingId);
    }

    private async ValueTask<IJSObjectReference> GetModuleAsync()
    {
        if (module is not null)
        {
            return module;
        }

        module = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./js/instructions.js");
        return module;
    }

    public async ValueTask DisposeAsync()
    {
        if (module is not null)
        {
            await module.DisposeAsync();
        }
    }
}
