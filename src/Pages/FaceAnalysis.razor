@page "/bildanalyse"
@using System.Globalization
@using Toolbox.Helpers
@using Toolbox.Models
@using Toolbox.Services
@using Toolbox.Settings
@using Toolbox.Components.FaceAnalysis
@inject FaceAnalysisService AnalysisService
@inject TemporaryImageStorage ImageStorage
@inject LocalStorageHelper LocalStorage
@inject IndexedDbHelper DbHelper

<PageTitle>@DisplayTexts.FaceAnalysisPageTitle</PageTitle>

<h1>@DisplayTexts.FaceAnalysisPageTitle</h1>

<div class="face-analysis-workflow">
    @switch (_currentStep)
    {
        case FaceAnalysisStep.DeckSelection:
            <FaceAnalysisDeckSelectionStep IntroText="@DisplayTexts.FaceAnalysisIntro"
                                           DeckOptions="_deckOptions"
                                           IsLoadingDecks="_isLoadingDecks"
                                           IsDeckDataLoading="_isDeckDataLoading"
                                           SelectedDeck="_selectedDeck"
                                           SelectedDeckChanged="HandleDeckSelectionChangedAsync"
                                           CardSearchTerm="_cardSearchTerm"
                                           CardSearchTermChanged="HandleCardSearchTermChangedAsync"
                                           CanSearchCards="CanSearchCards"
                                           ShouldShowCardNotFound="ShouldShowCardNotFound"
                                           SelectedCardDisplayName="@_selectedCard?.DisplayName"
                                           SelectedCardImageDataUrl="SelectedCardImageDataUrl"
                                           OnNext="GoToCaptureStep"
                                           IsNextEnabled="SelectedCardImageBytes is not null" />
            break;
        case FaceAnalysisStep.Capture:
            <FaceAnalysisCaptureStep OnBack="GoToDeckSelectionStep"
                                     OnPhotoCaptured="HandlePhotoCapturedAsync"
                                     OnStartAnalysis="StartAnalysisAsync"
                                     StatusMessage="_captureStatusMessage"
                                     ImageDataUrl="_imageDataUrl"
                                     IsAnalyzing="_isAnalyzing"
                                     IsStartEnabled="_lastImageData is not null"
                                     CardDisplayName="@_selectedCard?.DisplayName" />
            break;
        case FaceAnalysisStep.Analysis:
            <FaceAnalysisAnalysisStep OnBack="ReturnToCaptureStep"
                                      OnStartMerge="GoToMergeStep"
                                      AnalysisResult="_analysisResult"
                                      ImageDataUrl="_imageDataUrl"
                                      SummaryMessage="_analysisSummary"
                                      IsRefreshing="_isRefreshing"
                                      CanRefresh="_lastImageData is not null && !_isAnalyzing"
                                      ShowFaceOutline="_showFaceOutline"
                                      ShowLeftEye="_showLeftEye"
                                      ShowRightEye="_showRightEye"
                                      ShowNose="_showNose"
                                      OnShowFaceOutlineChanged="OnShowFaceOutlineChanged"
                                      OnShowLeftEyeChanged="OnShowLeftEyeChanged"
                                      OnShowRightEyeChanged="OnShowRightEyeChanged"
                                      OnShowNoseChanged="OnShowNoseChanged"
                                      OnRefresh="RefreshAnalysisAsync" />
            break;
        case FaceAnalysisStep.Merge:
            <FaceAnalysisMergeStep OnBack="ReturnToAnalysisStep"
                                   AnalysisResult="_analysisResult"
                                   PhotoImageBytes="_lastImageData"
                                   PhotoContentType="_lastImageContentType"
                                   CardImageBytes="SelectedCardImageBytes"
                                   CardDescription="@_selectedCard?.DisplayName" />
            break;
    }
</div>

@code {
    private readonly Dictionary<string, DeckCards> _deckCardsCache = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, string> _deckDisplayNames = new(StringComparer.OrdinalIgnoreCase);
    private IReadOnlyList<DeckOption> _deckOptions = Array.Empty<DeckOption>();
    private DeckCardInfo? _selectedCard;
    private string _selectedDeck = string.Empty;
    private string _cardSearchTerm = string.Empty;
    private FaceAnalysisStep _currentStep = FaceAnalysisStep.DeckSelection;
    private bool _isLoadingDecks;
    private bool _isDeckDataLoading;
    private string? _imageDataUrl;
    private string? _captureStatusMessage;
    private string? _analysisSummary;
    private FaceAnalysisResult? _analysisResult;
    private byte[]? _lastImageData;
    private string? _lastImageContentType;
    private bool _showFaceOutline = true;
    private bool _showLeftEye;
    private bool _showRightEye;
    private bool _showNose;
    private bool _isRefreshing;
    private bool _isAnalyzing;

    public byte[]? SelectedCardImageBytes
    {
        get; private set;
    }

    public string? SelectedCardImageDataUrl
    {
        get; private set;
    }

    private bool CanSearchCards => !_isLoadingDecks && !_isDeckDataLoading && !string.IsNullOrWhiteSpace(_selectedDeck);

    private bool ShouldShowCardNotFound => !string.IsNullOrWhiteSpace(_cardSearchTerm)
                                           && !_isDeckDataLoading
                                           && !string.IsNullOrWhiteSpace(_selectedDeck)
                                           && _selectedCard is null;

    protected override async Task OnInitializedAsync()
    {
        await Task.WhenAll(LoadOverlayPreferencesAsync(), InitializeDeckSelectionAsync());
    }

    private Task HandleDeckSelectionChangedAsync(string value)
    {
        var normalized = value ?? string.Empty;

        if (string.Equals(_selectedDeck, normalized, StringComparison.Ordinal))
        {
            return Task.CompletedTask;
        }

        _selectedDeck = normalized;
        _cardSearchTerm = string.Empty;
        ClearSelectedCard();

        return InvokeAsync(HandleDeckSelectionChangedInternalAsync);
    }

    private Task HandleDeckSelectionChangedInternalAsync()
    {
        if (string.IsNullOrWhiteSpace(_selectedDeck))
        {
            _cardSearchTerm = string.Empty;
            ClearSelectedCard();
            StateHasChanged();
            return Task.CompletedTask;
        }

        return UpdateSelectedCardAsync();
    }

    private Task HandleCardSearchTermChangedAsync(string value)
    {
        var newValue = value ?? string.Empty;

        if (string.Equals(_cardSearchTerm, newValue, StringComparison.Ordinal))
        {
            return Task.CompletedTask;
        }

        _cardSearchTerm = newValue;
        return InvokeAsync(UpdateSelectedCardAsync);
    }

    private async Task LoadOverlayPreferencesAsync()
    {
        var storedPreferences = await LocalStorage.GetItemAsync<FaceOverlayPreferences>(ApplicationSettings.FaceAnalysisOverlayPreferencesKey);

        if (storedPreferences is not null)
        {
            _showFaceOutline = storedPreferences.ShowFaceOutline;
            _showLeftEye = storedPreferences.ShowLeftEye;
            _showRightEye = storedPreferences.ShowRightEye;
            _showNose = storedPreferences.ShowNose;
            return;
        }

        await SaveOverlayPreferencesAsync();
    }

    private async Task InitializeDeckSelectionAsync()
    {
        try
        {
            _isLoadingDecks = true;
            await DbHelper.InitializeAsync();

            var decks = await DbHelper.GetAllDecksAsync();
            var orderedOptions = decks.Where(deck => !string.IsNullOrWhiteSpace(deck?.Id))
                                      .Select(deck =>
                                      {
                                          var deckId = deck!.Id!;
                                          var name = string.IsNullOrWhiteSpace(deck.Name) ? deckId : deck.Name!;
                                          return new DeckOption(deckId, CardSearchHelper.CreateDeckDisplayName(name));
                                      })
                                      .OrderBy(option => option.DisplayName, StringComparer.OrdinalIgnoreCase)
                                      .ToList();

            _deckOptions = orderedOptions;
            _deckDisplayNames.Clear();

            foreach (var option in orderedOptions)
            {
                _deckDisplayNames[option.DeckId] = option.DisplayName;
            }
        }
        finally
        {
            _isLoadingDecks = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task UpdateSelectedCardAsync()
    {
        var deckId = _selectedDeck;

        if (string.IsNullOrWhiteSpace(deckId))
        {
            ClearSelectedCard();
            await InvokeAsync(StateHasChanged);
            return;
        }

        if (!_deckCardsCache.TryGetValue(deckId, out var deckCards))
        {
            _isDeckDataLoading = true;
            await InvokeAsync(StateHasChanged);

            try
            {
                deckCards = await LoadDeckCardsFromDatabaseAsync(deckId);
                _deckCardsCache[deckId] = deckCards;
            }
            finally
            {
                _isDeckDataLoading = false;
            }
        }

        if (deckCards is null || deckCards.Cards.Count == 0)
        {
            ClearSelectedCard();
            await InvokeAsync(StateHasChanged);
            return;
        }

        SelectCardFromDeck(deckCards, _cardSearchTerm);
        await InvokeAsync(StateHasChanged);
    }

    private async Task<DeckCards> LoadDeckCardsFromDatabaseAsync(string deckId)
    {
        var cards = await DbHelper.GetCardsByDeckAsync(deckId);
        var deckDisplayName = GetDeckDisplayName(deckId);
        var orderedCards = cards.OrderBy(card => CardSearchHelper.CreateDisplayName(deckDisplayName, card.Id), StringComparer.OrdinalIgnoreCase)
                                .ToList();
        return new DeckCards(deckId, deckDisplayName, orderedCards);
    }

    private string GetDeckDisplayName(string deckId)
    {
        if (_deckDisplayNames.TryGetValue(deckId, out var displayName) && !string.IsNullOrWhiteSpace(displayName))
        {
            return displayName;
        }

        return CardSearchHelper.CreateDeckDisplayName(deckId);
    }

    private void SelectCardFromDeck(DeckCards deckCards, string searchTerm)
    {
        var normalized = CardSearchHelper.NormalizeForComparison(searchTerm);
        Spielkarte? match;

        if (string.IsNullOrEmpty(normalized))
        {
            match = deckCards.Cards.FirstOrDefault();
        }
        else
        {
            match = CardSearchHelper.FindMatchingCards(deckCards.Cards, deckCards.DeckId, normalized).FirstOrDefault();
        }

        if (match is null)
        {
            ClearSelectedCard();
            return;
        }

        var displayName = CardSearchHelper.CreateDisplayName(deckCards.DeckDisplayName, match.Id);
        var imageBytes = match.Image?.ToArray() ?? Array.Empty<byte>();
        var imageDataUrl = CardSearchHelper.CreateImageDataUrl(match.Image);

        _selectedCard = new DeckCardInfo(deckCards.DeckId, match.Id ?? string.Empty, displayName, imageDataUrl);
        SelectedCardImageBytes = imageBytes;
        SelectedCardImageDataUrl = imageDataUrl;
    }

    private void ClearSelectedCard()
    {
        _selectedCard = null;
        SelectedCardImageBytes = null;
        SelectedCardImageDataUrl = null;
    }

    private async Task HandlePhotoCapturedAsync(string imageId)
    {
        _captureStatusMessage = null;
        _analysisResult = null;
        _analysisSummary = null;
        _imageDataUrl = null;
        _lastImageData = null;
        _lastImageContentType = null;

        if (!ImageStorage.TryGetImage(imageId, out var storedImage))
        {
            _captureStatusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, "Bild konnte nicht geladen werden.");
            return;
        }

        try
        {
            _lastImageData = storedImage.Data;
            _lastImageContentType = storedImage.ContentType;
            _imageDataUrl = storedImage.ToDataUrl();
        }
        catch (Exception ex)
        {
            _captureStatusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, ex.Message);
            _lastImageData = null;
            _lastImageContentType = null;
            _imageDataUrl = null;
        }
        finally
        {
            ImageStorage.Remove(imageId);
        }
    }

    private async Task StartAnalysisAsync()
    {
        if (_lastImageData is null || string.IsNullOrWhiteSpace(_lastImageContentType))
        {
            _captureStatusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, "Es wurde kein Bild geladen.");
            return;
        }

        _isAnalyzing = true;
        _captureStatusMessage = null;
        _analysisSummary = null;

        try
        {
            _analysisResult = AnalysisService.Analyze(_lastImageData);
            _analysisSummary = _analysisResult is null ? null : BuildSummaryMessage(_analysisResult);
            _currentStep = FaceAnalysisStep.Analysis;
        }
        catch (Exception ex)
        {
            _captureStatusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, ex.Message);
        }
        finally
        {
            _isAnalyzing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task RefreshAnalysisAsync()
    {
        if (_lastImageData is null || string.IsNullOrWhiteSpace(_lastImageContentType))
        {
            return;
        }

        _isRefreshing = true;

        try
        {
            _imageDataUrl = BuildDataUrl(_lastImageData, _lastImageContentType);
            _analysisResult = AnalysisService.Analyze(_lastImageData);
            _analysisSummary = _analysisResult is null ? null : BuildSummaryMessage(_analysisResult);
        }
        catch (Exception ex)
        {
            _analysisSummary = string.Format(DisplayTexts.FaceAnalysisImageError, ex.Message);
        }
        finally
        {
            _isRefreshing = false;
        }
    }

    private Task OnShowFaceOutlineChanged(bool value)
    {
        _showFaceOutline = value;
        return SaveOverlayPreferencesAsync();
    }

    private Task OnShowLeftEyeChanged(bool value)
    {
        _showLeftEye = value;
        return SaveOverlayPreferencesAsync();
    }

    private Task OnShowRightEyeChanged(bool value)
    {
        _showRightEye = value;
        return SaveOverlayPreferencesAsync();
    }

    private Task OnShowNoseChanged(bool value)
    {
        _showNose = value;
        return SaveOverlayPreferencesAsync();
    }

    private Task SaveOverlayPreferencesAsync()
    {
        var preferences = new FaceOverlayPreferences
        {
            ShowFaceOutline = _showFaceOutline,
            ShowLeftEye = _showLeftEye,
            ShowRightEye = _showRightEye,
            ShowNose = _showNose
        };

        return LocalStorage.SetItemAsync(ApplicationSettings.FaceAnalysisOverlayPreferencesKey, preferences);
    }

    private static string BuildDataUrl(byte[] data, string contentType) => $"data:{contentType};base64,{Convert.ToBase64String(data)}";

    private static string BuildSummaryMessage(FaceAnalysisResult result)
    {
        if (!result.HasFace)
        {
            return DisplayTexts.FaceAnalysisMessageNoFace;
        }

        if (!result.IsLikelyHuman)
        {
            return DisplayTexts.FaceAnalysisMessageFaceButNotHuman;
        }

        var features = new List<string>();
        if (result.LeftEye is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureLeftEye);
        }

        if (result.RightEye is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureRightEye);
        }

        if (result.Nose is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureNose);
        }

        var featureSummary = features.Count > 0
            ? string.Join(", ", features)
            : DisplayTexts.FaceAnalysisFeatureFallback;

        return string.Format(
            DisplayTexts.FaceAnalysisMessageHuman,
            featureSummary,
            result.ConfidenceScore.ToString("P0", CultureInfo.CurrentCulture));
    }

    private void GoToCaptureStep()
    {
        _currentStep = FaceAnalysisStep.Capture;
    }

    private void GoToDeckSelectionStep()
    {
        _currentStep = FaceAnalysisStep.DeckSelection;
    }

    private void ReturnToCaptureStep()
    {
        _currentStep = FaceAnalysisStep.Capture;
    }

    private void GoToMergeStep()
    {
        _currentStep = FaceAnalysisStep.Merge;
    }

    private void ReturnToAnalysisStep()
    {
        _currentStep = FaceAnalysisStep.Analysis;
    }

    private sealed record DeckCardInfo(string DeckId, string CardId, string DisplayName, string ImageDataUrl);

    private sealed record DeckCards(string DeckId, string DeckDisplayName, IReadOnlyList<Spielkarte> Cards);

    private sealed class FaceOverlayPreferences
    {
        public bool ShowFaceOutline
        {
            get; set;
        } = true;

        public bool ShowLeftEye
        {
            get; set;
        }

        public bool ShowRightEye
        {
            get; set;
        }

        public bool ShowNose
        {
            get; set;
        }
    }

    private enum FaceAnalysisStep
    {
        DeckSelection,
        Capture,
        Analysis,
        Merge
    }
}
