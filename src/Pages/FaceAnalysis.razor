@page "/bildanalyse"
@using System.Globalization
@using Toolbox.Helpers
@using Toolbox.Models
@using Toolbox.Services
@using Toolbox.Settings
@inject FaceAnalysisService AnalysisService
@inject TemporaryImageStorage ImageStorage
@inject LocalStorageHelper LocalStorage

<PageTitle>@DisplayTexts.FaceAnalysisPageTitle</PageTitle>

<h1>@DisplayTexts.FaceAnalysisPageTitle</h1>
<p class="face-analysis-intro">@DisplayTexts.FaceAnalysisIntro</p>

<div class="face-analysis-controls">
    <CameraStream OnPhotoCaptured="HandlePhotoCapturedAsync" />
    @if (!string.IsNullOrWhiteSpace(_statusMessage))
    {
        <p class="face-analysis-status">@_statusMessage</p>
    }
</div>

@if (!string.IsNullOrEmpty(_imageDataUrl))
{
    <section class="face-analysis-overlay-options">
        <h2>@DisplayTexts.FaceAnalysisOverlayOptionsHeading</h2>
        <ul>
            <li>
                <label>
                    <InputCheckbox Value="@_showFaceOutline"
                                   ValueChanged="OnShowFaceOutlineChanged"
                                   ValueExpression="() => _showFaceOutline" />
                    <span>@DisplayTexts.FaceAnalysisOverlayOptionFace</span>
                </label>
            </li>
            <li>
                <label>
                    <InputCheckbox Value="@_showLeftEye"
                                   ValueChanged="OnShowLeftEyeChanged"
                                   ValueExpression="() => _showLeftEye" />
                    <span>@DisplayTexts.FaceAnalysisOverlayOptionLeftEye</span>
                </label>
            </li>
            <li>
                <label>
                    <InputCheckbox Value="@_showRightEye"
                                   ValueChanged="OnShowRightEyeChanged"
                                   ValueExpression="() => _showRightEye" />
                    <span>@DisplayTexts.FaceAnalysisOverlayOptionRightEye</span>
                </label>
            </li>
            <li>
                <label>
                    <InputCheckbox Value="@_showNose"
                                   ValueChanged="OnShowNoseChanged"
                                   ValueExpression="() => _showNose" />
                    <span>@DisplayTexts.FaceAnalysisOverlayOptionNose</span>
                </label>
            </li>
        </ul>
    </section>

    <section class="face-analysis-images">
        <figure>
            <figcaption>@DisplayTexts.FaceAnalysisOriginalCaption</figcaption>
            <img src="@_imageDataUrl" alt="@DisplayTexts.FaceAnalysisOriginalAlt" />
        </figure>

        <figure>
            <figcaption>@DisplayTexts.FaceAnalysisAnnotatedCaption</figcaption>
            <div class="face-analysis-annotated-wrapper">
                <img src="@_imageDataUrl" alt="@DisplayTexts.FaceAnalysisAnnotatedAlt" />
                @if (_analysisResult is not null && _analysisResult.HasFace)
                {
                    <svg class="face-analysis-overlay"
                         viewBox="0 0 @_analysisResult.ImageWidth @_analysisResult.ImageHeight"
                         xmlns="http://www.w3.org/2000/svg"
                         role="presentation">
                        @if (_showFaceOutline && _analysisResult.FaceBounds is BoundingBox face)
                        {
                            <rect class="face-outline"
                                  x="@face.X"
                                  y="@face.Y"
                                  width="@face.Width"
                                  height="@face.Height" />
                        }

                        @if (_showLeftEye && _analysisResult.LeftEye is FaceFeature leftEye)
                        {
                            <rect class="feature-outline"
                                  x="@leftEye.Bounds.X"
                                  y="@leftEye.Bounds.Y"
                                  width="@leftEye.Bounds.Width"
                                  height="@leftEye.Bounds.Height" />
                        }

                        @if (_showRightEye && _analysisResult.RightEye is FaceFeature rightEye)
                        {
                            <rect class="feature-outline"
                                  x="@rightEye.Bounds.X"
                                  y="@rightEye.Bounds.Y"
                                  width="@rightEye.Bounds.Width"
                                  height="@rightEye.Bounds.Height" />
                        }

                        @if (_showNose && _analysisResult.Nose is FaceFeature nose)
                        {
                            <rect class="feature-outline"
                                  x="@nose.Bounds.X"
                                  y="@nose.Bounds.Y"
                                  width="@nose.Bounds.Width"
                                  height="@nose.Bounds.Height" />
                        }
                    </svg>
                }
            </div>
        </figure>
    </section>

    <button type="button"
            class="face-analysis-refresh"
            @onclick="RefreshAnalysisAsync"
            disabled="@(_isRefreshing || _lastImageData is null)">
        @DisplayTexts.FaceAnalysisRefreshButton
    </button>
}

@if (_analysisResult is not null)
{
    <section class="face-analysis-summary">
        <h2>@DisplayTexts.FaceAnalysisSummaryHeading</h2>
        <p>@BuildSummaryMessage(_analysisResult)</p>
        <ul>
            <li>@DescribeFeature(_analysisResult.LeftEye, DisplayTexts.FaceAnalysisFeatureLeftEye)</li>
            <li>@DescribeFeature(_analysisResult.RightEye, DisplayTexts.FaceAnalysisFeatureRightEye)</li>
            <li>@DescribeFeature(_analysisResult.Nose, DisplayTexts.FaceAnalysisFeatureNose)</li>
        </ul>
    </section>
}

@code {
    private string? _imageDataUrl;
    private string? _statusMessage;
    private FaceAnalysisResult? _analysisResult;
    private byte[]? _lastImageData;
    private string? _lastImageContentType;
    private bool _showFaceOutline = true;
    private bool _showLeftEye;
    private bool _showRightEye;
    private bool _showNose;
    private bool _isRefreshing;

    protected override async Task OnInitializedAsync()
    {
        var storedPreferences = await LocalStorage.GetItemAsync<FaceOverlayPreferences>(ApplicationSettings.FaceAnalysisOverlayPreferencesKey);

        if (storedPreferences is not null)
        {
            _showFaceOutline = storedPreferences.ShowFaceOutline;
            _showLeftEye = storedPreferences.ShowLeftEye;
            _showRightEye = storedPreferences.ShowRightEye;
            _showNose = storedPreferences.ShowNose;
        }
        else
        {
            await SaveOverlayPreferencesAsync();
        }
    }

    private Task HandlePhotoCapturedAsync(string imageId)
    {
        _statusMessage = null;
        _analysisResult = null;
        _imageDataUrl = null;
        _lastImageData = null;
        _lastImageContentType = null;

        if (!ImageStorage.TryGetImage(imageId, out var storedImage))
        {
            _statusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, "Bild konnte nicht geladen werden.");
            return Task.CompletedTask;
        }

        try
        {
            _lastImageData = storedImage.Data;
            _lastImageContentType = storedImage.ContentType;
            _imageDataUrl = storedImage.ToDataUrl();
            _analysisResult = AnalysisService.Analyze(storedImage.Data);
            _statusMessage = BuildSummaryMessage(_analysisResult);
        }
        catch (Exception ex)
        {
            _statusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, ex.Message);
        }
        finally
        {
            ImageStorage.Remove(imageId);
        }

        return Task.CompletedTask;
    }

    private async Task RefreshAnalysisAsync()
    {
        if (_lastImageData is null || string.IsNullOrWhiteSpace(_lastImageContentType))
        {
            return;
        }

        _isRefreshing = true;

        try
        {
            _imageDataUrl = BuildDataUrl(_lastImageData, _lastImageContentType);
            _analysisResult = AnalysisService.Analyze(_lastImageData);
            _statusMessage = _analysisResult is null ? null : BuildSummaryMessage(_analysisResult);
        }
        catch (Exception ex)
        {
            _statusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, ex.Message);
        }
        finally
        {
            _isRefreshing = false;
        }
    }

    private async Task OnShowFaceOutlineChanged(bool value)
    {
        _showFaceOutline = value;
        await SaveOverlayPreferencesAsync();
    }

    private async Task OnShowLeftEyeChanged(bool value)
    {
        _showLeftEye = value;
        await SaveOverlayPreferencesAsync();
    }

    private async Task OnShowRightEyeChanged(bool value)
    {
        _showRightEye = value;
        await SaveOverlayPreferencesAsync();
    }

    private async Task OnShowNoseChanged(bool value)
    {
        _showNose = value;
        await SaveOverlayPreferencesAsync();
    }

    private Task SaveOverlayPreferencesAsync()
    {
        var preferences = new FaceOverlayPreferences
        {
            ShowFaceOutline = _showFaceOutline,
            ShowLeftEye = _showLeftEye,
            ShowRightEye = _showRightEye,
            ShowNose = _showNose
        };

        return LocalStorage.SetItemAsync(ApplicationSettings.FaceAnalysisOverlayPreferencesKey, preferences);
    }

    private static string BuildDataUrl(byte[] data, string contentType) => $"data:{contentType};base64,{Convert.ToBase64String(data)}";

    private static string BuildSummaryMessage(FaceAnalysisResult result)
    {
        if (!result.HasFace)
        {
            return DisplayTexts.FaceAnalysisMessageNoFace;
        }

        if (!result.IsLikelyHuman)
        {
            return DisplayTexts.FaceAnalysisMessageFaceButNotHuman;
        }

        var features = new List<string>();
        if (result.LeftEye is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureLeftEye);
        }

        if (result.RightEye is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureRightEye);
        }

        if (result.Nose is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureNose);
        }

        var featureSummary = features.Count > 0
            ? string.Join(", ", features)
            : DisplayTexts.FaceAnalysisFeatureFallback;

        return string.Format(
            DisplayTexts.FaceAnalysisMessageHuman,
            featureSummary,
            result.ConfidenceScore.ToString("P0", CultureInfo.CurrentCulture));
    }

    private static string DescribeFeature(FaceFeature? feature, string label)
    {
        if (feature is null)
        {
            return string.Format(DisplayTexts.FaceAnalysisFeatureMissing, label);
        }

        return string.Format(
            DisplayTexts.FaceAnalysisFeatureDetected,
            label,
            feature.Confidence.ToString("P1", CultureInfo.CurrentCulture));
    }

    private sealed class FaceOverlayPreferences
    {
        public bool ShowFaceOutline
        {
            get; set;
        } = true;

        public bool ShowLeftEye
        {
            get; set;
        }

        public bool ShowRightEye
        {
            get; set;
        }

        public bool ShowNose
        {
            get; set;
        }
    }
}
