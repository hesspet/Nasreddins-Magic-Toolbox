@page "/bildanalyse"
@using System.Globalization
@using Toolbox.Helpers
@using Toolbox.Models
@using Toolbox.Services
@using Toolbox.Settings
@inject FaceAnalysisService AnalysisService
@inject TemporaryImageStorage ImageStorage
@inject LocalStorageHelper LocalStorage
@inject IndexedDbHelper DbHelper

<PageTitle>@DisplayTexts.FaceAnalysisPageTitle</PageTitle>

<h1>@DisplayTexts.FaceAnalysisPageTitle</h1>

<div class="face-analysis-card-selection">
    <DeckSelectionBar IsLoading="_isLoadingDecks"
                      DeckOptions="_deckOptions"
                      @bind-SelectedDeck="SelectedDeck"
                      ShowSearchButton="false"
                      SearchEnabled="CanSearchCards" />

    <div class="face-analysis-card-search">
        <input id="@_cardSearchInputId"
               class="form-control"
               @bind="CardSearchTerm"
               @bind:event="oninput"
               placeholder="@DisplayTexts.TarotSearchLabel"
               title="@DisplayTexts.TarotSearchPlaceholder"
               aria-label="@DisplayTexts.TarotSearchLabel"
               disabled="@(!CanSearchCards)" />
    </div>

    @if (ShouldShowCardNotFound)
    {
        <p class="face-analysis-card-search-error">@DisplayTexts.TarotSearchNotFound</p>
    }

    @if (_selectedCard is not null)
    {
        <figure class="face-analysis-card-preview">
            <img src="@(SelectedCardImageDataUrl ?? string.Empty)"
                 alt="@_selectedCard.DisplayName" />
            <figcaption>@_selectedCard.DisplayName</figcaption>
        </figure>
    }
</div>

<p class="face-analysis-intro">@DisplayTexts.FaceAnalysisIntro</p>

<div class="face-analysis-controls">
    <CameraStream OnPhotoCaptured="HandlePhotoCapturedAsync" />
    @if (!string.IsNullOrWhiteSpace(_statusMessage))
    {
        <p class="face-analysis-status">@_statusMessage</p>
    }
</div>

@if (!string.IsNullOrEmpty(_imageDataUrl))
{
    <section class="face-analysis-overlay-options">
        <h2>@DisplayTexts.FaceAnalysisOverlayOptionsHeading</h2>
        <ul>
            <li>
                <label>
                    <InputCheckbox Value="@_showFaceOutline"
                                   ValueChanged="OnShowFaceOutlineChanged"
                                   ValueExpression="() => _showFaceOutline" />
                    <span>@DisplayTexts.FaceAnalysisOverlayOptionFace</span>
                </label>
            </li>
            <li>
                <label>
                    <InputCheckbox Value="@_showLeftEye"
                                   ValueChanged="OnShowLeftEyeChanged"
                                   ValueExpression="() => _showLeftEye" />
                    <span>@DisplayTexts.FaceAnalysisOverlayOptionLeftEye</span>
                </label>
            </li>
            <li>
                <label>
                    <InputCheckbox Value="@_showRightEye"
                                   ValueChanged="OnShowRightEyeChanged"
                                   ValueExpression="() => _showRightEye" />
                    <span>@DisplayTexts.FaceAnalysisOverlayOptionRightEye</span>
                </label>
            </li>
            <li>
                <label>
                    <InputCheckbox Value="@_showNose"
                                   ValueChanged="OnShowNoseChanged"
                                   ValueExpression="() => _showNose" />
                    <span>@DisplayTexts.FaceAnalysisOverlayOptionNose</span>
                </label>
            </li>
        </ul>
    </section>

    <section class="face-analysis-images">
        <figure>
            <figcaption>@DisplayTexts.FaceAnalysisOriginalCaption</figcaption>
            <img src="@_imageDataUrl" alt="@DisplayTexts.FaceAnalysisOriginalAlt" />
        </figure>

        <figure>
            <figcaption>@DisplayTexts.FaceAnalysisAnnotatedCaption</figcaption>
            <div class="face-analysis-annotated-wrapper">
                <img src="@_imageDataUrl" alt="@DisplayTexts.FaceAnalysisAnnotatedAlt" />
                @if (_analysisResult is not null && _analysisResult.HasFace)
                {
                    <svg class="face-analysis-overlay"
                         viewBox="0 0 @_analysisResult.ImageWidth @_analysisResult.ImageHeight"
                         xmlns="http://www.w3.org/2000/svg"
                         role="presentation">
                        @if (_showFaceOutline && _analysisResult.FaceBounds is BoundingBox face)
                        {
                            <rect class="face-outline"
                                  x="@face.X"
                                  y="@face.Y"
                                  width="@face.Width"
                                  height="@face.Height" />
                        }

                        @if (_showLeftEye && _analysisResult.LeftEye is FaceFeature leftEye)
                        {
                            <rect class="feature-outline"
                                  x="@leftEye.Bounds.X"
                                  y="@leftEye.Bounds.Y"
                                  width="@leftEye.Bounds.Width"
                                  height="@leftEye.Bounds.Height" />
                        }

                        @if (_showRightEye && _analysisResult.RightEye is FaceFeature rightEye)
                        {
                            <rect class="feature-outline"
                                  x="@rightEye.Bounds.X"
                                  y="@rightEye.Bounds.Y"
                                  width="@rightEye.Bounds.Width"
                                  height="@rightEye.Bounds.Height" />
                        }

                        @if (_showNose && _analysisResult.Nose is FaceFeature nose)
                        {
                            <rect class="feature-outline"
                                  x="@nose.Bounds.X"
                                  y="@nose.Bounds.Y"
                                  width="@nose.Bounds.Width"
                                  height="@nose.Bounds.Height" />
                        }
                    </svg>
                }
            </div>
        </figure>
    </section>

    <button type="button"
            class="face-analysis-refresh"
            @onclick="RefreshAnalysisAsync"
            disabled="@(_isRefreshing || _lastImageData is null)">
        @DisplayTexts.FaceAnalysisRefreshButton
    </button>
}

@if (_analysisResult is not null)
{
    <section class="face-analysis-summary">
        <h2>@DisplayTexts.FaceAnalysisSummaryHeading</h2>
        <p>@BuildSummaryMessage(_analysisResult)</p>
        <ul>
            <li>@DescribeFeature(_analysisResult.LeftEye, DisplayTexts.FaceAnalysisFeatureLeftEye)</li>
            <li>@DescribeFeature(_analysisResult.RightEye, DisplayTexts.FaceAnalysisFeatureRightEye)</li>
            <li>@DescribeFeature(_analysisResult.Nose, DisplayTexts.FaceAnalysisFeatureNose)</li>
        </ul>
    </section>
}

@if (_analysisResult is not null
    && _analysisResult.Nose is not null
    && _analysisResult.HasFace
    && SelectedCardImageBytes is not null
    && _lastImageData is not null
    && !string.IsNullOrWhiteSpace(_lastImageContentType))
{
    <FaceAnalysisCardOverlay PhotoImageBytes="_lastImageData"
                              PhotoContentType="_lastImageContentType"
                              AnalysisResult="_analysisResult"
                              CardImageBytes="SelectedCardImageBytes"
                              CardDescription="@_selectedCard?.DisplayName" />
}

@code {
    private readonly Dictionary<string, DeckCards> _deckCardsCache = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, string> _deckDisplayNames = new(StringComparer.OrdinalIgnoreCase);
    private readonly string _cardSearchInputId = $"faceAnalysisCardSearch_{System.Guid.NewGuid():N}";
    private IReadOnlyList<DeckOption> _deckOptions = Array.Empty<DeckOption>();
    private DeckCardInfo? _selectedCard;
    private string _selectedDeck = string.Empty;
    private string _cardSearchTerm = string.Empty;
    public byte[]? SelectedCardImageBytes
    {
        get; private set;
    }

    public string? SelectedCardImageDataUrl
    {
        get; private set;
    }
    private bool _isLoadingDecks;
    private bool _isDeckDataLoading;
    private string? _imageDataUrl;
    private string? _statusMessage;
    private FaceAnalysisResult? _analysisResult;
    private byte[]? _lastImageData;
    private string? _lastImageContentType;
    private bool _showFaceOutline = true;
    private bool _showLeftEye;
    private bool _showRightEye;
    private bool _showNose;
    private bool _isRefreshing;

    private bool CanSearchCards => !_isLoadingDecks && !_isDeckDataLoading && !string.IsNullOrWhiteSpace(_selectedDeck);

    private bool ShouldShowCardNotFound => !string.IsNullOrWhiteSpace(_cardSearchTerm)
                                           && !_isDeckDataLoading
                                           && !string.IsNullOrWhiteSpace(_selectedDeck)
                                           && _selectedCard is null;

    private string SelectedDeck
    {
        get => _selectedDeck;
        set
        {
            var normalized = value ?? string.Empty;

            if (string.Equals(_selectedDeck, normalized, StringComparison.Ordinal))
            {
                return;
            }

            _selectedDeck = normalized;
            _cardSearchTerm = string.Empty;
            ClearSelectedCard();

            _ = InvokeAsync(HandleDeckSelectionChangedAsync);
        }
    }

    private string CardSearchTerm
    {
        get => _cardSearchTerm;
        set
        {
            var newValue = value ?? string.Empty;

            if (string.Equals(_cardSearchTerm, newValue, StringComparison.Ordinal))
            {
                return;
            }

            _cardSearchTerm = newValue;
            _ = InvokeAsync(UpdateSelectedCardAsync);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await Task.WhenAll(LoadOverlayPreferencesAsync(), InitializeDeckSelectionAsync());
    }

    private async Task LoadOverlayPreferencesAsync()
    {
        var storedPreferences = await LocalStorage.GetItemAsync<FaceOverlayPreferences>(ApplicationSettings.FaceAnalysisOverlayPreferencesKey);

        if (storedPreferences is not null)
        {
            _showFaceOutline = storedPreferences.ShowFaceOutline;
            _showLeftEye = storedPreferences.ShowLeftEye;
            _showRightEye = storedPreferences.ShowRightEye;
            _showNose = storedPreferences.ShowNose;
            return;
        }

        await SaveOverlayPreferencesAsync();
    }

    private async Task InitializeDeckSelectionAsync()
    {
        try
        {
            _isLoadingDecks = true;
            await DbHelper.InitializeAsync();

            var decks = await DbHelper.GetAllDecksAsync();
            var orderedOptions = decks.Where(deck => !string.IsNullOrWhiteSpace(deck?.Id))
                                      .Select(deck =>
                                      {
                                          var deckId = deck!.Id!;
                                          var name = string.IsNullOrWhiteSpace(deck.Name) ? deckId : deck.Name!;
                                          return new DeckOption(deckId, CardSearchHelper.CreateDeckDisplayName(name));
                                      })
                                      .OrderBy(option => option.DisplayName, StringComparer.OrdinalIgnoreCase)
                                      .ToList();

            _deckOptions = orderedOptions;
            _deckDisplayNames.Clear();

            foreach (var option in orderedOptions)
            {
                _deckDisplayNames[option.DeckId] = option.DisplayName;
            }
        }
        finally
        {
            _isLoadingDecks = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleDeckSelectionChangedAsync()
    {
        if (string.IsNullOrWhiteSpace(_selectedDeck))
        {
            _cardSearchTerm = string.Empty;
            ClearSelectedCard();
            StateHasChanged();
            return;
        }

        await UpdateSelectedCardAsync();
    }

    private async Task UpdateSelectedCardAsync()
    {
        var deckId = _selectedDeck;

        if (string.IsNullOrWhiteSpace(deckId))
        {
            ClearSelectedCard();
            await InvokeAsync(StateHasChanged);
            return;
        }

        if (!_deckCardsCache.TryGetValue(deckId, out var deckCards))
        {
            _isDeckDataLoading = true;
            await InvokeAsync(StateHasChanged);

            try
            {
                deckCards = await LoadDeckCardsFromDatabaseAsync(deckId);
                _deckCardsCache[deckId] = deckCards;
            }
            finally
            {
                _isDeckDataLoading = false;
            }
        }

        if (deckCards is null || deckCards.Cards.Count == 0)
        {
            ClearSelectedCard();
            await InvokeAsync(StateHasChanged);
            return;
        }

        SelectCardFromDeck(deckCards, _cardSearchTerm);
        await InvokeAsync(StateHasChanged);
    }

    private async Task<DeckCards> LoadDeckCardsFromDatabaseAsync(string deckId)
    {
        var cards = await DbHelper.GetCardsByDeckAsync(deckId);
        var deckDisplayName = GetDeckDisplayName(deckId);
        var orderedCards = cards.OrderBy(card => CardSearchHelper.CreateDisplayName(deckDisplayName, card.Id), StringComparer.OrdinalIgnoreCase)
                                .ToList();
        return new DeckCards(deckId, deckDisplayName, orderedCards);
    }

    private string GetDeckDisplayName(string deckId)
    {
        if (_deckDisplayNames.TryGetValue(deckId, out var displayName) && !string.IsNullOrWhiteSpace(displayName))
        {
            return displayName;
        }

        return CardSearchHelper.CreateDeckDisplayName(deckId);
    }

    private void SelectCardFromDeck(DeckCards deckCards, string searchTerm)
    {
        var normalized = CardSearchHelper.NormalizeForComparison(searchTerm);
        Spielkarte? match;

        if (string.IsNullOrEmpty(normalized))
        {
            match = deckCards.Cards.FirstOrDefault();
        }
        else
        {
            match = CardSearchHelper.FindMatchingCards(deckCards.Cards, deckCards.DeckId, normalized).FirstOrDefault();
        }

        if (match is null)
        {
            ClearSelectedCard();
            return;
        }

        var displayName = CardSearchHelper.CreateDisplayName(deckCards.DeckDisplayName, match.Id);
        var imageBytes = match.Image?.ToArray() ?? Array.Empty<byte>();
        var imageDataUrl = CardSearchHelper.CreateImageDataUrl(match.Image);

        _selectedCard = new DeckCardInfo(deckCards.DeckId, match.Id ?? string.Empty, displayName, imageDataUrl);
        SelectedCardImageBytes = imageBytes;
        SelectedCardImageDataUrl = imageDataUrl;
    }

    private void ClearSelectedCard()
    {
        _selectedCard = null;
        SelectedCardImageBytes = null;
        SelectedCardImageDataUrl = null;
    }

    private Task HandlePhotoCapturedAsync(string imageId)
    {
        _statusMessage = null;
        _analysisResult = null;
        _imageDataUrl = null;
        _lastImageData = null;
        _lastImageContentType = null;

        if (!ImageStorage.TryGetImage(imageId, out var storedImage))
        {
            _statusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, "Bild konnte nicht geladen werden.");
            return Task.CompletedTask;
        }

        try
        {
            _lastImageData = storedImage.Data;
            _lastImageContentType = storedImage.ContentType;
            _imageDataUrl = storedImage.ToDataUrl();
            _analysisResult = AnalysisService.Analyze(storedImage.Data);
            _statusMessage = BuildSummaryMessage(_analysisResult);
        }
        catch (Exception ex)
        {
            _statusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, ex.Message);
        }
        finally
        {
            ImageStorage.Remove(imageId);
        }

        return Task.CompletedTask;
    }

    private async Task RefreshAnalysisAsync()
    {
        if (_lastImageData is null || string.IsNullOrWhiteSpace(_lastImageContentType))
        {
            return;
        }

        _isRefreshing = true;

        try
        {
            _imageDataUrl = BuildDataUrl(_lastImageData, _lastImageContentType);
            _analysisResult = AnalysisService.Analyze(_lastImageData);
            _statusMessage = _analysisResult is null ? null : BuildSummaryMessage(_analysisResult);
        }
        catch (Exception ex)
        {
            _statusMessage = string.Format(DisplayTexts.FaceAnalysisImageError, ex.Message);
        }
        finally
        {
            _isRefreshing = false;
        }
    }

    private async Task OnShowFaceOutlineChanged(bool value)
    {
        _showFaceOutline = value;
        await SaveOverlayPreferencesAsync();
    }

    private async Task OnShowLeftEyeChanged(bool value)
    {
        _showLeftEye = value;
        await SaveOverlayPreferencesAsync();
    }

    private async Task OnShowRightEyeChanged(bool value)
    {
        _showRightEye = value;
        await SaveOverlayPreferencesAsync();
    }

    private async Task OnShowNoseChanged(bool value)
    {
        _showNose = value;
        await SaveOverlayPreferencesAsync();
    }

    private Task SaveOverlayPreferencesAsync()
    {
        var preferences = new FaceOverlayPreferences
        {
            ShowFaceOutline = _showFaceOutline,
            ShowLeftEye = _showLeftEye,
            ShowRightEye = _showRightEye,
            ShowNose = _showNose
        };

        return LocalStorage.SetItemAsync(ApplicationSettings.FaceAnalysisOverlayPreferencesKey, preferences);
    }

    private static string BuildDataUrl(byte[] data, string contentType) => $"data:{contentType};base64,{Convert.ToBase64String(data)}";

    private static string BuildSummaryMessage(FaceAnalysisResult result)
    {
        if (!result.HasFace)
        {
            return DisplayTexts.FaceAnalysisMessageNoFace;
        }

        if (!result.IsLikelyHuman)
        {
            return DisplayTexts.FaceAnalysisMessageFaceButNotHuman;
        }

        var features = new List<string>();
        if (result.LeftEye is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureLeftEye);
        }

        if (result.RightEye is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureRightEye);
        }

        if (result.Nose is not null)
        {
            features.Add(DisplayTexts.FaceAnalysisFeatureNose);
        }

        var featureSummary = features.Count > 0
            ? string.Join(", ", features)
            : DisplayTexts.FaceAnalysisFeatureFallback;

        return string.Format(
            DisplayTexts.FaceAnalysisMessageHuman,
            featureSummary,
            result.ConfidenceScore.ToString("P0", CultureInfo.CurrentCulture));
    }

    private static string DescribeFeature(FaceFeature? feature, string label)
    {
        if (feature is null)
        {
            return string.Format(DisplayTexts.FaceAnalysisFeatureMissing, label);
        }

        return string.Format(
            DisplayTexts.FaceAnalysisFeatureDetected,
            label,
            feature.Confidence.ToString("P1", CultureInfo.CurrentCulture));
    }

    private sealed record DeckCardInfo(string DeckId, string CardId, string DisplayName, string ImageDataUrl);

    private sealed record DeckCards(string DeckId, string DeckDisplayName, IReadOnlyList<Spielkarte> Cards);

    private sealed class FaceOverlayPreferences
    {
        public bool ShowFaceOutline
        {
            get; set;
        } = true;

        public bool ShowLeftEye
        {
            get; set;
        }

        public bool ShowRightEye
        {
            get; set;
        }

        public bool ShowNose
        {
            get; set;
        }
    }
}
