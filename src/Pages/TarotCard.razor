@page "/tarot"
@using System.Collections.Generic
@using System.Linq
@using System.IO
@using System.Reflection
@using System.Threading
@using Markdig
@implements IDisposable
@inject HttpClient HttpClient

<PageTitle>@DisplayTexts.TarotPageTitle</PageTitle>

<div class="tarot-page">
    <h1>@DisplayTexts.TarotHeader</h1>

    <p>@(new MarkupString(DisplayTexts.TarotSearchInstructions))</p>

    <div class="tarot-search">
        <label class="form-label" for="cardNameInput">@DisplayTexts.TarotSearchLabel</label>
        <input id="cardNameInput"
               class="form-control"
               @bind="SearchTerm"
               @bind:event="oninput"
               placeholder="@DisplayTexts.TarotSearchPlaceholder" />
    </div>

    <div class="tarot-search">
        <label class="form-label" for="deckSelection">@DisplayTexts.TarotDeckSelectionLabel</label>
        <select id="deckSelection"
                class="form-select"
                @bind="SelectedDeck">
            @foreach (var option in DeckOptions)
            {
                <option value="@option.DeckName">@option.DisplayName</option>
            }
        </select>
    </div>

    @if (HasSearched && selectedCard is null)
    {
        <p class="text-danger">@DisplayTexts.TarotSearchNotFound</p>
    }

    @if (selectedCard is not null)
    {
        <figure class="tarot-card">
            <img src="@selectedCard.ImageDataUrl" alt="@selectedCard.DisplayName" class="img-fluid" />
            <figcaption>@selectedCard.DisplayName</figcaption>
        </figure>

        <section class="tarot-card-description" aria-live="polite">
            @if (isDescriptionLoading)
            {
                <p>@DisplayTexts.TarotDescriptionLoading</p>
            }
            else if (!string.IsNullOrEmpty(descriptionError))
            {
                <p class="text-danger">@descriptionError</p>
            }
            else if (!string.IsNullOrEmpty(selectedCardDescriptionHtml))
            {
                <div class="tarot-card-description-content">@((MarkupString)selectedCardDescriptionHtml)</div>
            }
        </section>
    }
</div>

@if (selectedCard is not null)
{
    <nav class="tarot-navigation-bar" aria-label="@DisplayTexts.TarotHeader">
        <button type="button"
                class="btn btn-outline-secondary"
                aria-label="@DisplayTexts.TarotPreviousCardButton"
                title="@DisplayTexts.TarotPreviousCardButton"
                @onclick="ShowPreviousCard">
            &larr;
        </button>

        <button type="button"
                class="btn btn-outline-secondary"
                aria-label="@DisplayTexts.TarotNextCardButton"
                title="@DisplayTexts.TarotNextCardButton"
                @onclick="ShowNextCard">
            &rarr;
        </button>
    </nav>
}

@code {
    private static readonly Assembly ResourceAssembly = typeof(TarotCard).Assembly;
    private static readonly string ImageResourcePrefix = $"{typeof(DisplayTexts).Namespace}.Images.";
    private static readonly TarotDeckCollection DeckCollection = LoadDeckCollection();

    private string searchTerm = string.Empty;
    private string selectedDeck = DeckCollection.DefaultDeck;
    private TarotCardInfo? selectedCard;
    private int selectedCardIndex = -1;
    private bool HasSearched => !string.IsNullOrWhiteSpace(searchTerm);
    private readonly Dictionary<string, string> cardDescriptionCache = new(StringComparer.OrdinalIgnoreCase);
    private CancellationTokenSource? descriptionCts;
    private string? selectedCardDescriptionHtml;
    private bool isDescriptionLoading;
    private string? descriptionError;

    private string SearchTerm
    {
        get => searchTerm;
        set
        {
            if (searchTerm == value)
            {
                return;
            }

            searchTerm = value ?? string.Empty;
            UpdateSelection();
        }
    }

    private string SelectedDeck
    {
        get => selectedDeck;
        set
        {
            var newValue = string.IsNullOrWhiteSpace(value) ? DeckCollection.DefaultDeck : value;
            if (selectedDeck == newValue)
            {
                return;
            }

            selectedDeck = newValue;
            selectedCardIndex = -1;
            UpdateSelection();
        }
    }

    private IEnumerable<TarotDeckOption> DeckOptions => DeckCollection.Options;

    protected override void OnInitialized()
    {
        if (string.IsNullOrWhiteSpace(selectedDeck))
        {
            selectedDeck = DeckCollection.DefaultDeck;
        }

        UpdateSelection();
    }

    private static TarotDeckCollection LoadDeckCollection()
    {
        var cards = ResourceAssembly.GetManifestResourceNames()
                                    .Where(IsImageResource)
                                    .Select(CreateCardInfo)
                                    .OfType<TarotCardInfo>()
                                    .ToList();

        var cardsByDeck = cards.GroupBy(card => card.DeckName)
                               .ToDictionary(group => group.Key,
                                             group => (IReadOnlyList<TarotCardInfo>)group.OrderBy(card => card.DisplayName)
                                                                                         .ToList(),
                                             StringComparer.OrdinalIgnoreCase);

        var defaultDeck = cardsByDeck.Keys.OrderBy(name => name, StringComparer.OrdinalIgnoreCase)
                                          .FirstOrDefault()
                           ?? string.Empty;

        return new TarotDeckCollection(cardsByDeck, defaultDeck);
    }

    private static bool IsImageResource(string resourceName) =>
        resourceName.StartsWith(ImageResourcePrefix, StringComparison.OrdinalIgnoreCase)
        && (resourceName.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase)
            || resourceName.EndsWith(".jpeg", StringComparison.OrdinalIgnoreCase));

    private static TarotCardInfo? CreateCardInfo(string resourceName)
    {
        if (!resourceName.StartsWith(ImageResourcePrefix, StringComparison.Ordinal))
        {
            return null;
        }

        var relativeName = resourceName[ImageResourcePrefix.Length..];
        var segments = relativeName.Split('.', StringSplitOptions.RemoveEmptyEntries);
        if (segments.Length < 2)
        {
            return null;
        }

        var deckName = segments[0];
        var fileName = string.Join('.', segments.Skip(1));
        var displayName = CreateDisplayName(deckName, fileName);
        var key = CreateKey(deckName, fileName);
        return new TarotCardInfo(displayName, deckName, fileName, key, resourceName);
    }

    private static string CreateDisplayName(string deckName, string fileName)
    {
        var nameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
        var cardName = nameWithoutExtension.Replace('_', ' ');
        var friendlyDeckName = deckName.Replace('_', ' ');
        return $"{friendlyDeckName}: {cardName}";
    }

    private static string CreateKey(string deckName, string fileName)
    {
        var composite = string.Concat(deckName, "_", Path.GetFileNameWithoutExtension(fileName));
        var filtered = composite.Where(char.IsLetterOrDigit);
        return string.Concat(filtered);
    }

    private static string CreateDeckDisplayName(string deckName) => deckName.Replace('_', ' ');

    private void UpdateSelection()
    {
        var deckToSearch = string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck;
        var candidates = DeckCollection.GetCards(deckToSearch);

        if (candidates.Count == 0)
        {
            selectedCard = null;
            selectedCardIndex = -1;
            ClearSelectedCardDescription();
            return;
        }

        var normalized = NormalizeForComparison(searchTerm);
        if (normalized.Length == 0)
        {
            if (selectedCardIndex < 0 || selectedCardIndex >= candidates.Count)
            {
                ShowCardAtIndex(0, candidates);
            }
            else
            {
                ShowCardAtIndex(selectedCardIndex, candidates);
            }

            return;
        }

        var matchingIndex = FindMatchingCardIndex(candidates, normalized);
        if (matchingIndex >= 0)
        {
            ShowCardAtIndex(matchingIndex, candidates);
        }
        else
        {
            selectedCard = null;
            selectedCardIndex = -1;
            ClearSelectedCardDescription();
        }
    }

    private static int FindMatchingCardIndex(IReadOnlyList<TarotCardInfo> candidates, string normalizedSearch)
    {
        for (var index = 0; index < candidates.Count; index++)
        {
            if (candidates[index].ComparisonKey.Contains(normalizedSearch, StringComparison.OrdinalIgnoreCase))
            {
                return index;
            }
        }

        return -1;
    }

    private void ShowCardAtIndex(int index, IReadOnlyList<TarotCardInfo>? candidates = null)
    {
        candidates ??= DeckCollection.GetCards(string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck);
        if (candidates.Count == 0)
        {
            selectedCard = null;
            selectedCardIndex = -1;
            ClearSelectedCardDescription();
            return;
        }

        var normalizedIndex = ((index % candidates.Count) + candidates.Count) % candidates.Count;
        selectedCardIndex = normalizedIndex;
        selectedCard = candidates[normalizedIndex];
        PrepareCardDescription(selectedCard);
    }

    private void ShowNextCard()
    {
        var candidates = DeckCollection.GetCards(string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck);
        if (candidates.Count == 0)
        {
            return;
        }

        var nextIndex = selectedCardIndex >= 0 ? selectedCardIndex + 1 : 0;
        ShowCardAtIndex(nextIndex, candidates);
    }

    private void ShowPreviousCard()
    {
        var candidates = DeckCollection.GetCards(string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck);
        if (candidates.Count == 0)
        {
            return;
        }

        var previousIndex = selectedCardIndex >= 0 ? selectedCardIndex - 1 : candidates.Count - 1;
        ShowCardAtIndex(previousIndex, candidates);
    }

    private static string NormalizeForComparison(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return string.Empty;
        }

        var filtered = value.Where(char.IsLetterOrDigit)
                            .Select(char.ToLowerInvariant);
        return string.Concat(filtered);
    }

    private void PrepareCardDescription(TarotCardInfo card)
    {
        descriptionCts?.Cancel();
        descriptionCts?.Dispose();

        if (cardDescriptionCache.TryGetValue(card.MarkdownRelativePath, out var cachedHtml))
        {
            selectedCardDescriptionHtml = cachedHtml;
            descriptionError = null;
            isDescriptionLoading = false;
            descriptionCts = null;
            return;
        }

        descriptionError = null;
        selectedCardDescriptionHtml = null;
        isDescriptionLoading = true;

        var cts = new CancellationTokenSource();
        descriptionCts = cts;
        _ = LoadDescriptionCoreAsync(card, cts.Token);
    }

    private async Task LoadDescriptionCoreAsync(TarotCardInfo card, CancellationToken token)
    {
        try
        {
            var markdown = await HttpClient.GetStringAsync(card.MarkdownRelativePath, token);
            var html = Markdown.ToHtml(markdown);
            cardDescriptionCache[card.MarkdownRelativePath] = html;

            if (token.IsCancellationRequested || selectedCard?.Key != card.Key)
            {
                return;
            }

            selectedCardDescriptionHtml = html;
            descriptionError = null;
        }
        catch (OperationCanceledException)
        {
            return;
        }
        catch
        {
            if (token.IsCancellationRequested || selectedCard?.Key != card.Key)
            {
                return;
            }

            descriptionError = DisplayTexts.TarotDescriptionLoadError;
            selectedCardDescriptionHtml = null;
        }
        finally
        {
            if (token.IsCancellationRequested || selectedCard?.Key != card.Key)
            {
                return;
            }

            isDescriptionLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ClearSelectedCardDescription()
    {
        descriptionCts?.Cancel();
        descriptionCts?.Dispose();
        descriptionCts = null;
        selectedCardDescriptionHtml = null;
        descriptionError = null;
        isDescriptionLoading = false;
    }

    private sealed record TarotCardInfo(string DisplayName, string DeckName, string FileName, string Key, string ResourceName)
    {
        private string? imageDataUrl;

        public string ImageDataUrl => imageDataUrl ??= LoadImageData(ResourceName);
        public string ComparisonKey => NormalizeForComparison(Key);
        public string MarkdownRelativePath
        {
            get
            {
                var markdownFileName = Path.ChangeExtension(FileName, ".md") ?? string.Empty;
                var combined = Path.Combine("Resources", "Images", DeckName, markdownFileName);
                return combined.Replace('\\', '/');
            }
        }

        private static string LoadImageData(string resourceName)
        {
            using var stream = ResourceAssembly.GetManifestResourceStream(resourceName);
            if (stream is null)
            {
                return string.Empty;
            }

            using var memoryStream = new MemoryStream();
            stream.CopyTo(memoryStream);
            var base64 = Convert.ToBase64String(memoryStream.ToArray());
            return $"data:image/jpeg;base64,{base64}";
        }
    }

    private sealed record TarotDeckCollection(IReadOnlyDictionary<string, IReadOnlyList<TarotCardInfo>> CardsByDeck, string DefaultDeck)
    {
        public IEnumerable<TarotDeckOption> Options => CardsByDeck.Keys
                                                                   .OrderBy(name => name, StringComparer.OrdinalIgnoreCase)
                                                                   .Select(name => new TarotDeckOption(name, CreateDeckDisplayName(name)));

        public IReadOnlyList<TarotCardInfo> GetCards(string deckName)
        {
            if (CardsByDeck.TryGetValue(deckName, out var cards))
            {
                return cards;
            }

            return Array.Empty<TarotCardInfo>();
        }
    }

    private sealed record TarotDeckOption(string DeckName, string DisplayName);

    public void Dispose()
    {
        descriptionCts?.Cancel();
        descriptionCts?.Dispose();
    }
}
