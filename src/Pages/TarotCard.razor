@page "/tarot"
@using System.Collections.Generic
@using System.Linq
@using System.IO
@using System.Reflection
@using System.Text
@using System.Threading
@using System.Threading.Tasks
@using Markdig
@implements IDisposable

<PageTitle>@DisplayTexts.TarotPageTitle</PageTitle>

<div class="tarot-page">
    <h1>@DisplayTexts.TarotHeader</h1>

    <div class="tarot-search">
        <label class="form-label" for="cardNameInput">@DisplayTexts.TarotSearchLabel</label>
        <input id="cardNameInput"
               class="form-control"
               @bind="SearchTerm"
               @bind:event="oninput"
               placeholder="@DisplayTexts.TarotSearchPlaceholder" />
    </div>

    <div class="tarot-search">
        <label class="form-label" for="deckSelection">@DisplayTexts.TarotDeckSelectionLabel</label>
        <select id="deckSelection"
                class="form-select"
                @bind="SelectedDeck">
            @foreach (var option in DeckOptions)
            {
                <option value="@option.DeckName">@option.DisplayName</option>
            }
        </select>
    </div>

    @if (HasSearched && selectedCard is null)
    {
        <p class="text-danger">@DisplayTexts.TarotSearchNotFound</p>
    }

    @if (selectedCard is not null)
    {
        <figure class="tarot-card">
            <img src="@selectedCard.ImageDataUrl" alt="@selectedCard.DisplayName" class="img-fluid" />
            <figcaption>@selectedCard.DisplayName</figcaption>
        </figure>

        <section class="tarot-card-description" aria-live="polite">
            @if (isDescriptionLoading)
            {
                <p>@DisplayTexts.TarotDescriptionLoading</p>
            }
            else if (!string.IsNullOrEmpty(descriptionError))
            {
                <p class="text-danger">@descriptionError</p>
            }
            else if (!string.IsNullOrEmpty(selectedCardDescriptionHtml))
            {
                <div class="tarot-card-description-content">@((MarkupString)selectedCardDescriptionHtml)</div>
            }
        </section>
    }
</div>

@if (selectedCard is not null)
{
    <nav class="tarot-navigation-bar" aria-label="@DisplayTexts.TarotHeader">
        <button type="button"
                class="btn btn-outline-secondary"
                aria-label="@DisplayTexts.TarotPreviousCardButton"
                title="@DisplayTexts.TarotPreviousCardButton"
                @onclick="ShowPreviousCard">
            &larr;
        </button>

        <button type="button"
                class="btn btn-outline-secondary"
                aria-label="@DisplayTexts.TarotNextCardButton"
                title="@DisplayTexts.TarotNextCardButton"
                @onclick="ShowNextCard">
            &rarr;
        </button>
    </nav>
}

<section class="tarot-deck-actions">
    <h2>@DisplayTexts.TarotShareHeader</h2>
    <p class="text-muted">@DisplayTexts.TarotShareDescription</p>

    <div class="btn-toolbar" role="toolbar" aria-label="@DisplayTexts.TarotShareHeader">
        <div class="btn-group me-2" role="group">
            <button type="button"
                    class="btn btn-primary"
                    disabled="@(!isShareSupported || isSharingDeck)"
                    @onclick="ShareSelectedDeckAsync">
                @DisplayTexts.TarotShareDeckButton
            </button>
        </div>

        <div class="btn-group" role="group">
            <button type="button"
                    class="btn btn-outline-primary"
                    disabled="@(isCachingDeck)"
                    @onclick="() => RequestDeckCache(force: true)">
                @DisplayTexts.TarotCacheDeckButton
            </button>
        </div>
    </div>

    @if (!isShareSupported)
    {
        <p class="text-warning mt-2">@DisplayTexts.TarotShareUnsupported</p>
    }

    @if (!string.IsNullOrEmpty(shareError))
    {
        <p class="text-danger mt-2">@shareError</p>
    }

    @if (!string.IsNullOrEmpty(cacheStatusMessage))
    {
        <p class="mt-2">@cacheStatusMessage</p>
    }
</section>

<section class="tarot-import-section">
    <h2>@DisplayTexts.TarotImportHeader</h2>
    <p class="text-muted">@DisplayTexts.TarotImportDescription</p>

    <div class="row g-3">
        <div class="col-12 col-md-6">
            <label class="form-label" for="importDeckName">@DisplayTexts.TarotImportDeckNameLabel</label>
            <input id="importDeckName"
                   class="form-control"
                   @bind="importDeckName"
                   placeholder="@DisplayTexts.TarotImportDeckNamePlaceholder" />
        </div>

        <div class="col-12">
            <label class="form-label" for="deckFilesInput">@DisplayTexts.TarotImportFilesLabel</label>
            <InputFile id="deckFilesInput"
                       OnChange="HandleImportFilesSelected"
                       multiple
                       accept=".jpg,.jpeg,.md,.markdown" />
            <div class="form-text">
                @string.Format(DisplayTexts.TarotImportFilesCount, selectedImportFiles.Count)
            </div>
        </div>
    </div>

    <div class="mt-3">
        <button type="button"
                class="btn btn-success"
                disabled="@(isImporting || selectedImportFiles.Count == 0 || string.IsNullOrWhiteSpace(importDeckName))"
                @onclick="ImportDeckAsync">
            @DisplayTexts.TarotImportButton
        </button>
    </div>

    @if (!string.IsNullOrEmpty(importStatusMessage))
    {
        <p class="mt-2">@importStatusMessage</p>
    }

    @if (!string.IsNullOrEmpty(importError))
    {
        <p class="text-danger mt-2">@importError</p>
    }
</section>

@code {
    private static readonly Assembly ResourceAssembly = typeof(TarotCard).Assembly;
    private static readonly string ImageResourcePrefix = $"{typeof(DisplayTexts).Namespace}.Images.";
    private static readonly TarotDeckCollection DeckCollection = LoadDeckCollection();

    [Inject]
    private IJSRuntime JSRuntime { get; set; } = default!;

    [Inject]
    private LocalStorageHelper LocalStorage { get; set; } = default!;

    private string searchTerm = string.Empty;
    private string selectedDeck = DeckCollection.DefaultDeck;
    private TarotCardInfo? selectedCard;
    private int selectedCardIndex = -1;
    private bool HasSearched => !string.IsNullOrWhiteSpace(searchTerm);
    private readonly Dictionary<string, string> cardDescriptionCache = new(StringComparer.OrdinalIgnoreCase);
    private CancellationTokenSource? descriptionCts;
    private string? selectedCardDescriptionHtml;
    private bool isDescriptionLoading;
    private string? descriptionError;
    private IJSObjectReference? shareModule;
    private bool isShareSupported;
    private bool isSharingDeck;
    private string? shareError;
    private bool isCachingDeck;
    private string? cacheStatusMessage;
    private readonly HashSet<string> cachedDecks = new(StringComparer.OrdinalIgnoreCase);
    private string importDeckName = string.Empty;
    private List<IBrowserFile> selectedImportFiles = new();
    private bool isImporting;
    private string? importStatusMessage;
    private string? importError;

    private string SearchTerm
    {
        get => searchTerm;
        set
        {
            if (searchTerm == value)
            {
                return;
            }

            searchTerm = value ?? string.Empty;
            UpdateSelection();
        }
    }

    private string SelectedDeck
    {
        get => selectedDeck;
        set
        {
            var newValue = string.IsNullOrWhiteSpace(value) ? DeckCollection.DefaultDeck : value;
            if (selectedDeck == newValue)
            {
                return;
            }

            selectedDeck = newValue;
            selectedCardIndex = -1;
            UpdateSelection();
            RequestDeckCache(force: false);
        }
    }

    private IEnumerable<TarotDeckOption> DeckOptions => DeckCollection.Options;

    protected override void OnInitialized()
    {
        if (string.IsNullOrWhiteSpace(selectedDeck))
        {
            selectedDeck = DeckCollection.DefaultDeck;
        }

        UpdateSelection();
        RequestDeckCache(force: false);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        shareModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/webShare.js");
        if (shareModule is not null)
        {
            isShareSupported = await shareModule.InvokeAsync<bool>("isShareSupported");
            await InvokeAsync(StateHasChanged);
        }
    }

    private static TarotDeckCollection LoadDeckCollection()
    {
        var cards = ResourceAssembly.GetManifestResourceNames()
                                    .Where(IsImageResource)
                                    .Select(CreateCardInfo)
                                    .OfType<TarotCardInfo>()
                                    .ToList();

        var cardsByDeck = cards.GroupBy(card => card.DeckName)
                               .ToDictionary(group => group.Key,
                                             group => (IReadOnlyList<TarotCardInfo>)group.OrderBy(card => card.DisplayName)
                                                                                         .ToList(),
                                             StringComparer.OrdinalIgnoreCase);

        var defaultDeck = cardsByDeck.Keys.OrderBy(name => name, StringComparer.OrdinalIgnoreCase)
                                          .FirstOrDefault()
                           ?? string.Empty;

        return new TarotDeckCollection(cardsByDeck, defaultDeck);
    }

    private static bool IsImageResource(string resourceName) =>
        resourceName.StartsWith(ImageResourcePrefix, StringComparison.OrdinalIgnoreCase)
        && (resourceName.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase)
            || resourceName.EndsWith(".jpeg", StringComparison.OrdinalIgnoreCase));

    private static TarotCardInfo? CreateCardInfo(string resourceName)
    {
        if (!resourceName.StartsWith(ImageResourcePrefix, StringComparison.Ordinal))
        {
            return null;
        }

        var relativeName = resourceName[ImageResourcePrefix.Length..];
        var segments = relativeName.Split('.', StringSplitOptions.RemoveEmptyEntries);
        if (segments.Length < 2)
        {
            return null;
        }

        var deckName = segments[0];
        var fileName = string.Join('.', segments.Skip(1));
        var displayName = CreateDisplayName(deckName, fileName);
        var key = CreateKey(deckName, fileName);
        return new TarotCardInfo(displayName, deckName, fileName, key, resourceName);
    }

    private static string CreateDisplayName(string deckName, string fileName)
    {
        var nameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
        var cardName = nameWithoutExtension.Replace('_', ' ');
        var friendlyDeckName = deckName.Replace('_', ' ');
        return $"{friendlyDeckName}: {cardName}";
    }

    private static string CreateKey(string deckName, string fileName)
    {
        var composite = string.Concat(deckName, "_", Path.GetFileNameWithoutExtension(fileName));
        var filtered = composite.Where(char.IsLetterOrDigit);
        return string.Concat(filtered);
    }

    private static string CreateDeckDisplayName(string deckName) => deckName.Replace('_', ' ');

    private void UpdateSelection()
    {
        var deckToSearch = string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck;
        var candidates = DeckCollection.GetCards(deckToSearch);

        if (candidates.Count == 0)
        {
            selectedCard = null;
            selectedCardIndex = -1;
            ClearSelectedCardDescription();
            return;
        }

        var normalized = NormalizeForComparison(searchTerm);
        if (normalized.Length == 0)
        {
            if (selectedCardIndex < 0 || selectedCardIndex >= candidates.Count)
            {
                ShowCardAtIndex(0, candidates);
            }
            else
            {
                ShowCardAtIndex(selectedCardIndex, candidates);
            }

            return;
        }

        var matchingIndex = FindMatchingCardIndex(candidates, normalized);
        if (matchingIndex >= 0)
        {
            ShowCardAtIndex(matchingIndex, candidates);
        }
        else
        {
            selectedCard = null;
            selectedCardIndex = -1;
            ClearSelectedCardDescription();
        }
    }

    private static int FindMatchingCardIndex(IReadOnlyList<TarotCardInfo> candidates, string normalizedSearch)
    {
        for (var index = 0; index < candidates.Count; index++)
        {
            if (candidates[index].ComparisonKey.Contains(normalizedSearch, StringComparison.OrdinalIgnoreCase))
            {
                return index;
            }
        }

        return -1;
    }

    private void ShowCardAtIndex(int index, IReadOnlyList<TarotCardInfo>? candidates = null)
    {
        candidates ??= DeckCollection.GetCards(string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck);
        if (candidates.Count == 0)
        {
            selectedCard = null;
            selectedCardIndex = -1;
            ClearSelectedCardDescription();
            return;
        }

        var normalizedIndex = ((index % candidates.Count) + candidates.Count) % candidates.Count;
        selectedCardIndex = normalizedIndex;
        selectedCard = candidates[normalizedIndex];
        PrepareCardDescription(selectedCard);
    }

    private void ShowNextCard()
    {
        var candidates = DeckCollection.GetCards(string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck);
        if (candidates.Count == 0)
        {
            return;
        }

        var nextIndex = selectedCardIndex >= 0 ? selectedCardIndex + 1 : 0;
        ShowCardAtIndex(nextIndex, candidates);
    }

    private void ShowPreviousCard()
    {
        var candidates = DeckCollection.GetCards(string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck);
        if (candidates.Count == 0)
        {
            return;
        }

        var previousIndex = selectedCardIndex >= 0 ? selectedCardIndex - 1 : candidates.Count - 1;
        ShowCardAtIndex(previousIndex, candidates);
    }

    private static string NormalizeForComparison(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return string.Empty;
        }

        var filtered = value.Where(char.IsLetterOrDigit)
                            .Select(char.ToLowerInvariant);
        return string.Concat(filtered);
    }

    private void PrepareCardDescription(TarotCardInfo card)
    {
        descriptionCts?.Cancel();
        descriptionCts?.Dispose();

        var cacheKey = card.MarkdownResourceName;
        if (cardDescriptionCache.TryGetValue(cacheKey, out var cachedHtml))
        {
            selectedCardDescriptionHtml = cachedHtml;
            descriptionError = null;
            isDescriptionLoading = false;
            descriptionCts = null;
            return;
        }

        descriptionError = null;
        selectedCardDescriptionHtml = null;
        isDescriptionLoading = true;

        var cts = new CancellationTokenSource();
        descriptionCts = cts;
        _ = LoadDescriptionCoreAsync(card, cacheKey, cts.Token);
    }

    private async Task LoadDescriptionCoreAsync(TarotCardInfo card, string cacheKey, CancellationToken token)
    {
        try
        {
            using var stream = ResourceAssembly.GetManifestResourceStream(card.MarkdownResourceName);
            if (stream is null)
            {
                throw new InvalidOperationException($"Resource '{card.MarkdownResourceName}' not found.");
            }

            using var reader = new StreamReader(stream);
            var markdown = await reader.ReadToEndAsync(token);
            var html = Markdown.ToHtml(markdown);
            cardDescriptionCache[cacheKey] = html;

            if (token.IsCancellationRequested || selectedCard?.Key != card.Key)
            {
                return;
            }

            selectedCardDescriptionHtml = html;
            descriptionError = null;
        }
        catch (OperationCanceledException)
        {
            return;
        }
        catch
        {
            if (token.IsCancellationRequested || selectedCard?.Key != card.Key)
            {
                return;
            }

            descriptionError = DisplayTexts.TarotDescriptionLoadError;
            selectedCardDescriptionHtml = null;
        }
        finally
        {
            if (!(token.IsCancellationRequested || selectedCard?.Key != card.Key))
            {
                isDescriptionLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void ClearSelectedCardDescription()
    {
        descriptionCts?.Cancel();
        descriptionCts?.Dispose();
        descriptionCts = null;
        selectedCardDescriptionHtml = null;
        descriptionError = null;
        isDescriptionLoading = false;
    }

    private void RequestDeckCache(bool force)
    {
        var deckToCache = string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck;
        if (string.IsNullOrWhiteSpace(deckToCache))
        {
            return;
        }

        if (!force && cachedDecks.Contains(deckToCache))
        {
            return;
        }

        _ = InvokeAsync(() => CacheDeckInLocalStorageAsync(deckToCache, force));
    }

    private async Task CacheDeckInLocalStorageAsync(string deckName, bool force)
    {
        if (!force && cachedDecks.Contains(deckName))
        {
            return;
        }

        try
        {
            isCachingDeck = true;
            cacheStatusMessage = DisplayTexts.TarotCacheDeckInProgress;
            await InvokeAsync(StateHasChanged);

            var files = await BuildDeckFilesAsync(deckName);
            if (files.Count == 0)
            {
                cacheStatusMessage = DisplayTexts.TarotCacheDeckEmpty;
                return;
            }

            var payload = new DeckStoragePayload(deckName,
                                                 DateTimeOffset.UtcNow,
                                                 files.Select(file => new DeckFileStorage(file.FileName, file.ContentType, file.Base64Data)).ToList());

            await LocalStorage.SetItemAsync($"tarotDeck:{deckName}", payload);
            cachedDecks.Add(deckName);
            cacheStatusMessage = string.Format(DisplayTexts.TarotCacheDeckSuccess, deckName, files.Count);
        }
        catch (Exception ex)
        {
            cacheStatusMessage = string.Format(DisplayTexts.TarotCacheDeckError, ex.Message);
        }
        finally
        {
            isCachingDeck = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task<List<DeckFileShare>> BuildDeckFilesAsync(string deckName)
    {
        var files = new List<DeckFileShare>();
        var cards = DeckCollection.GetCards(deckName);
        if (cards.Count == 0)
        {
            return files;
        }

        foreach (var card in cards)
        {
            var imageDataUrl = card.ImageDataUrl;
            var separatorIndex = imageDataUrl.IndexOf(',', StringComparison.Ordinal);
            var imageBase64 = separatorIndex >= 0 ? imageDataUrl[(separatorIndex + 1)..] : imageDataUrl;
            files.Add(new DeckFileShare(card.FileName, "image/jpeg", imageBase64));

            using var markdownStream = ResourceAssembly.GetManifestResourceStream(card.MarkdownResourceName);
            if (markdownStream is null)
            {
                continue;
            }

            using var reader = new StreamReader(markdownStream, Encoding.UTF8, leaveOpen: false);
            var markdown = await reader.ReadToEndAsync();
            var markdownBytes = Encoding.UTF8.GetBytes(markdown);
            var markdownBase64 = Convert.ToBase64String(markdownBytes);
            var markdownFileName = Path.ChangeExtension(card.FileName, ".md") ?? card.FileName + ".md";
            files.Add(new DeckFileShare(markdownFileName, "text/markdown", markdownBase64));
        }

        return files;
    }

    private async Task ShareSelectedDeckAsync()
    {
        shareError = null;
        var deckToShare = string.IsNullOrWhiteSpace(selectedDeck) ? DeckCollection.DefaultDeck : selectedDeck;
        if (!isShareSupported)
        {
            shareError = DisplayTexts.TarotShareUnsupported;
            return;
        }

        try
        {
            isSharingDeck = true;
            var files = await BuildDeckFilesAsync(deckToShare);
            if (files.Count == 0)
            {
                shareError = DisplayTexts.TarotShareNoFiles;
                return;
            }

            shareModule ??= await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/webShare.js");
            if (shareModule is null)
            {
                shareError = DisplayTexts.TarotShareUnsupported;
                return;
            }

            await shareModule.InvokeVoidAsync("shareDeck", deckToShare, files);
            cacheStatusMessage = string.Format(DisplayTexts.TarotShareSuccess, deckToShare, files.Count);
        }
        catch (JSException jsEx)
        {
            shareError = jsEx.Message;
        }
        catch (Exception ex)
        {
            shareError = string.Format(DisplayTexts.TarotShareGenericError, ex.Message);
        }
        finally
        {
            isSharingDeck = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void HandleImportFilesSelected(InputFileChangeEventArgs args)
    {
        selectedImportFiles = args.GetMultipleFiles().ToList();
        importStatusMessage = null;
        importError = null;
    }

    private async Task ImportDeckAsync()
    {
        importError = null;
        importStatusMessage = null;

        if (string.IsNullOrWhiteSpace(importDeckName))
        {
            importError = DisplayTexts.TarotImportMissingDeckName;
            return;
        }

        if (selectedImportFiles.Count == 0)
        {
            importError = DisplayTexts.TarotImportNoFiles;
            return;
        }

        try
        {
            isImporting = true;
            await InvokeAsync(StateHasChanged);

            var files = new List<DeckFileStorage>();
            foreach (var file in selectedImportFiles)
            {
                var base64 = await ReadFileAsBase64Async(file);
                files.Add(new DeckFileStorage(file.Name, file.ContentType, base64));
            }

            var payload = new DeckStoragePayload(importDeckName.Trim(), DateTimeOffset.UtcNow, files);
            await LocalStorage.SetItemAsync($"tarotDeck:{payload.DeckName}", payload);
            cachedDecks.Add(payload.DeckName);
            importStatusMessage = string.Format(DisplayTexts.TarotImportSuccess, payload.DeckName, files.Count);
        }
        catch (Exception ex)
        {
            importError = string.Format(DisplayTexts.TarotImportError, ex.Message);
        }
        finally
        {
            isImporting = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private static async Task<string> ReadFileAsBase64Async(IBrowserFile file)
    {
        const long MaxAllowedSize = 15 * 1024 * 1024;
        await using var stream = file.OpenReadStream(MaxAllowedSize);
        using var memoryStream = new MemoryStream();
        await stream.CopyToAsync(memoryStream);
        return Convert.ToBase64String(memoryStream.ToArray());
    }


    private sealed record TarotCardInfo(string DisplayName, string DeckName, string FileName, string Key, string ResourceName)
    {
        private string? imageDataUrl;

        public string ImageDataUrl => imageDataUrl ??= LoadImageData(ResourceName);
        public string ComparisonKey => NormalizeForComparison(Key);
        public string MarkdownResourceName
        {
            get
            {
                var markdownResource = Path.ChangeExtension(ResourceName, ".md");
                return string.IsNullOrEmpty(markdownResource) ? ResourceName : markdownResource;
            }
        }

        private static string LoadImageData(string resourceName)
        {
            using var stream = ResourceAssembly.GetManifestResourceStream(resourceName);
            if (stream is null)
            {
                return string.Empty;
            }

            using var memoryStream = new MemoryStream();
            stream.CopyTo(memoryStream);
            var base64 = Convert.ToBase64String(memoryStream.ToArray());
            return $"data:image/jpeg;base64,{base64}";
        }
    }

    private sealed record TarotDeckCollection(IReadOnlyDictionary<string, IReadOnlyList<TarotCardInfo>> CardsByDeck, string DefaultDeck)
    {
        public IEnumerable<TarotDeckOption> Options => CardsByDeck.Keys
                                                                   .OrderBy(name => name, StringComparer.OrdinalIgnoreCase)
                                                                   .Select(name => new TarotDeckOption(name, CreateDeckDisplayName(name)));

        public IReadOnlyList<TarotCardInfo> GetCards(string deckName)
        {
            if (CardsByDeck.TryGetValue(deckName, out var cards))
            {
                return cards;
            }

            return Array.Empty<TarotCardInfo>();
        }
    }

    private sealed record TarotDeckOption(string DeckName, string DisplayName);

    private sealed record DeckFileShare(string FileName, string ContentType, string Base64Data);

    private sealed record DeckFileStorage(string FileName, string ContentType, string Base64Data);

    private sealed record DeckStoragePayload(string DeckName, DateTimeOffset CachedAt, IReadOnlyList<DeckFileStorage> Files);

    public void Dispose()
    {
        descriptionCts?.Cancel();
        descriptionCts?.Dispose();
        if (shareModule is not null)
        {
            _ = shareModule.DisposeAsync();
        }
    }
}
